--[[ Lua 迭代器 ]]
-- 迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中确定的地址。
-- 在Lua中迭代器是一种支持指针类型的结构，他可以遍历集合的每一个元素。
-- 泛型for迭代器
-- 泛型for在自己内部保存迭代函数，实际上他报错三个中：迭代函数，状态常量，控制变量。
-- 泛型for迭代器提供了集合的key/value对，语法格式如下：
-- for k, v in pairs(t) do
--     print(k,v)
-- end
-- 上面的代码中，k,v为变量列表；pairs(t)为表达式列表。
-- 实例
-- array={"Google","Runoob"}
-- for key, value in ipairs(array)
-- do
--     print(key,value)
-- end
-- 以上实例中国我们使用了Lua默认提供的迭代函数ipairs。
-- 下面我们看看泛型for执行的过程:
-- 首先，初始化，计算in后面的表达式的值，表达式应该返回泛型for需要的三个值：迭代函数，状态常量，控制变量；
-- 与多赋值一样，如果表达式个数补足三个会自动用nil补足，多出的部分会被忽略。
-- 第二。将转台常量可控制变量做完参数调用迭代函数（注意：对于for结构来说，状态常量没有用处，j仅仅在初始化时获取他的值并传递给迭代函数）。
-- 第三，将迭代函数返回的值赋给变量列表。
-- 第四，如果返回的第一个值为nil循环结束，否则执行循环体。
-- 第五，回到第二步再次调用迭代函数
-- 在Lua中我们常常使用函数来描述迭代器，每次调用该函数就返回集合的下一个元素。在Lua的迭代器包含以下两种类型：
-- 无状态的迭代器
-- 多状态的迭代器
--[[ 无状态的迭代器 ]]
-- 无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包话费额外的代价。
-- 每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值左右参数被调用，一个武装的迭代器只利用这个两个值可以获取下一个元素。
-- 这种无状态迭代器的典型的简单里例子就是ipairs,它遍历数组的每一个元素，元素的索引需要数值。
-- 以下实例我们使用了一个简单的函数来实现迭代器，实现数字n的平方：
-- function square(iteratorMaxCount,currentNumber)
--     if currentNumber<iteratorMaxCount then
--         currentNumber=currentNumber+1
--         return currentNumber,currentNumber*currentNumber
--     end
-- end
-- for i ,n in square,3,0 do
--     print(i,n)
-- end
-- 迭代的状态包括被遍历的表（循环过程中不会改变的状态常量）和当前索引下标（控制变量），ipairs和迭代函数都很简单，我们在Lua中可以这样实现：
-- function iter (a,i)
--     i=i+1
--     local v=a[i]
--     if v then
--         return i,v
--     end
-- end
-- function ipairs(a)
--     return iter,a,0
-- end
-- 在Lua中调用ipairs(a)开始循环时，他获取三个值：迭代函数iter，状态常量a，控制变量初始值0；
-- 然后Lua调用iter(a,0),返回1,a[1]（除非a[1]=nil）;第二季迭代器调用iter(a,1)返回2，a[2]......直到第一个nil元素。
--[[ 多状体迭代器 ]]
-- 很多情况下迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，j最简单的方法就是使用闭包，还有一种方法就是将所有的状态信息封装到table内，
-- 将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数；
-- 以下实例我们创建了我们自己的迭代器：
-- array={"Google","Runoob"}
-- function elementIterator (collection)
--     local index = 0
--     local count = #collection
--     -- 闭包函数
--     return function ()
--        index = index + 1
--        if index <= count
--        then
--           --  返回迭代器的当前元素
--           return collection[index]
--        end
--     end
--  end
--  for element in elementIterator(array)
--  do
--     print(element)
--  end
-- 以上实例中我们可以看到，elementIterator内使用了闭包函数，实现计算集合大小并输出各个元素。
--[[ pairs和ipairs区别 ]]
-- ・pairs：迭代table，可以遍历表中所有的key可以返回nil
-- ・ipairs：迭代数组，不能返回nil，如果遇到nil则退出
-- local tab = {
--     [1]="a",
--     [3]="b",
--     [4]="c"
-- }
-- for key, value in pairs(tab) do
--     print(tab[key])   --输出"a","b","c"
-- end
-- for index, value in ipairs(tab) do
--     print(index)   --输出"a",k=2时断开
-- end
--[[ pairs和ipairs异同 ]]
-- 同：都是能遍历集合（表，数组）
-- 异：ipairs仅仅遍历值，按照索引升序遍历，索引中断停止遍历。不能返回nil，只能返回数字0，如果遇到nil则退出。它只能遍历到集合中出现的第一个不是整数的Key。
--     pairs能遍历集合所有元素。即pairs可以遍历集合中所有的key，并且除了迭代器本身以及遍历表本身还可以返回nil。
-- 实例1:
-- local tabFiles={
--     [1]="test2",
--     [4]="test3",
--     [6]="test1"
-- }
-- for k, v in ipairs(tabFiles) do   --输出"test2",在key等于2处断开
--     print(k,v)
-- end
-- 实例2:
-- local tabFiles = {
--     [2]="test2",
--     [6]="test3",
--     [4]="test1"
-- }
-- for k, v in ipairs(tabFiles) do  --什么都没有输出，因为控制变量的初始值是按升序来遍历的，当key值为1是，value为1，此时便停止了遍历，所以什么结果都没有输出
--     print(k,v)
-- end
-- 实例3:
-- local tabFiles = {
--     [2]="test2",
--     [6]="test3",
--     [4]="test1"
-- }
-- for k, v in pairs(tabFiles) do--pairs能遍历所有元素，遇到nil不会停
--     print(k,v)
-- end
-- 实例4：
-- local tabFiles={
--     "alpha",
--     "beta",
--     [3]="no",
--     ["two"]="yes"
-- }
-- for i, v in ipairs(tabFiles) do
--     print(i,v)
-- end
-- for i, v in pairs(tabFiles) do--全部输出
--      print(i,v)
-- end
--[[ 字符串分割函数 ]]
-- function split(str,delimiter)
--     local dLen = string.len(delimiter)
--     local newDeli=''
--     for i = 1, dLen, 1 do
--         newDeli=newDeli.."["..string.sub(delimiter,i,i).."]"
--     end
--     local localStart,localEnd = string.find(str, newDeli)
--     local arr= {}
--     local n = 1
--     while localStart ~=nil
--      do
--         if localStart>0 then
--             arr[n]=string.sub(str,1,localStart-1)
--             n=n+1
--         end
--         str=string.sub(str, localEnd+1, string.len(str))
--         localStart,localEnd=string.find(str, newDeli)
--     end
--     if str~= nil then
--         arr[n]=str
--     end
--     return arr
-- end
-- t=split("php,js", ",")
-- for k, v in ipairs(t) do
--     print(k,v)
-- end
--[[ 泛型for在迭代的时候每次调用的都是闭包函数，迭代函数只是开始的时候调用一次。 ]]
-- function eleiter(t)
--     local index=0
--     print('in eleiter function')--每次调用迭代函数都说一句：in eleiter fucntion
--         return function()
--             print('I am here.')-->每次调用闭包函数都说一句：I am here
--             index=index+1
--             return t[index]
--         end
-- end
-- t={'one','two','three','four','five'}
-- for ele in eleiter(t) do
--     print(ele)
-- end
--[[ 泛for内维持3个要素 ]]
-- ・1：迭代函数本身，如pairs(tab)
-- ・2：迭代函数的状态常量，如tab
-- ・3：迭代函数的控制变量，如idx
-- 要求：每次调用一次迭代函数，函数执行过程后改变一次控制变量，但控制变量满足条件后，终止再次调用迭代函数。
-- 实例
-- function iter (a, i)
--     i = i + 1
--     local v = a[i]
--     if v then
--        return i, v
--     end
-- end
-- function ipairss (a)
--     i=0;
--    while(true) do
--         k,v=iter(a,i)
--         if k=nil then
--            break;
--        end
-- end
-- t={"asdf1","asdf2","asdf3","asdf4"}
-- for k,v in ipairss(t) do  //--内部维持iter,t,i三个要素,其中i隐含--这是我的理解
--     print(k,v)
-- end
--[[ pairs和ipairs的另外一个区别 ]]
-- ・ipairs迭代是会略过非数值的索引
-- ・pairs迭代不会略过非数值的索引
-- tab={1,2}
-- tab["key"]=6
-- for k, v in ipairs(tab) do
--     print(k,v)
--     print(tab["key"])
-- end
-- print("----------------------")
-- for k, v in pairs(tab) do
--     print(k,v)
-- end
